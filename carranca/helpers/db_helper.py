"""
Database data retrieve & operations for SQLAlchemy
returns a standard

mgd
Equipe da Canoa -- 2024
"""

# cSpell:ignore sqlalchemy slqaRecords connstr

from typing import Optional, Union, Tuple, Any, Callable, List
from sqlalchemy import text, Column
from sqlalchemy.orm import Session
from sqlalchemy.exc import DatabaseError, OperationalError, ProgrammingError
from sqlalchemy.engine import CursorResult

# from psycopg2.errors import ProgrammingError as psycopg2_ProgrammingError

from .py_helper import is_str_none_or_empty, to_str
from .types_helper import ui_db_texts

from .. import global_sqlalchemy_scoped_session
from ..config import BaseConfig
from ..common.app_context_vars import sidekick
from ..common.app_error_assistant import AppStumbled, ModuleErrorCode


def try_get_mgd_msg(error: object, default_msg: str = None) -> str:
    """
    Extracts a custom error message (surrounded by markers)
    from the argument error string, that is typically
    generated by database trigger.

    If not found, the default_msg is returned.

    Example:

    `raise exception '[^|O SEP "%" está atualmente atribuído. Não ...|^]', fullname;`

    """
    start_mgd_marker = "[^|"
    end_mgd_marker = "|^]"
    error_string = to_str(error)
    default_msg = error_string if is_str_none_or_empty(default_msg) else default_msg

    start_index = error_string.find(start_mgd_marker)
    end_index = error_string.find(end_mgd_marker, start_index + len(start_mgd_marker))

    if end_index == -1:
        return default_msg
    else:
        mgd_message = error_string[start_index + len(start_mgd_marker) : end_index]
        is_mgd = len(mgd_message) > 1
        return mgd_message if is_mgd else default_msg


def col_names_to_columns(
    column_names: List[str], columns: list[Column]
) -> List[Column]:
    if not column_names:
        return columns

    selected_cols = [col for col in columns if col.name in column_names]
    return selected_cols


def db_fetch_rows(
    func_or_query: str | Callable[[Session, Any], Any],
    table_name: str = "",
    return_tuple_len: int = 1,
    *args,
    **kwargs,
) -> Tuple[Optional[Exception], Optional[str], Tuple[Any, ...] | CursorResult]:
    """
    Executes a SQL query or a function within a database session.

    Args:
        func_or_query: A callable function or a SQL query string.
        table_name ['']: if not None and an error occurs, the exception is raised here
        return_tuple_len [1]: int the size of the tuple to return
        *args: Additional positional arguments to pass to the function.
        **kwargs: Additional keyword arguments to pass to the function.

    Returns:
        A tuple containing:
            - An error or None
            - A message error or None
            - if type of func_or_query is
                callable: A tuple of `return_tuple_len` size
                str: CursorResult

        A tuple containing an error (if any) and the result of the query or function.

    """

    def _do_return_error(e: Exception, msg: str) -> Tuple[Exception, str, Tuple]:
        from ..common.app_context_vars import sidekick

        # TODO LOG to log
        err_code = f"[{e.code}]" if hasattr(e, "code") else ""
        sidekick.display.error(
            f"[{func_or_query}]: '{msg}'; Table: [{table_name}]; Error{err_code} details: {e}."
        )

        if table_name:
            db_ups_error(e, msg, table_name)

        return e, msg, tuple([None] * return_tuple_len)

    try:
        db_session: Session
        with global_sqlalchemy_scoped_session() as db_session:
            if callable(func_or_query):
                returned = func_or_query(db_session, *args, **kwargs)
                return None, None, returned
            elif isinstance(func_or_query, str):
                query = text(func_or_query)
                cursor: CursorResult = db_session.execute(query)
                return None, None, cursor
            else:
                return _do_return_error(
                    TypeError(f"Invalid argument type in {__name__}"),
                    f"[{func_or_query}]: is not callable nor str.",
                )
    # https://docs.sqlalchemy.org/en/13/errors.html
    # https://docs.sqlalchemy.org/en/13/errors.html#programmingerror
    except ProgrammingError as e:
        return _do_return_error(e, "Evaluating the SQL request.")

    # https://docs.sqlalchemy.org/en/13/errors.html#operationalerror
    except (OperationalError, DatabaseError) as e:
        return _do_return_error(e, "Database connection error.")

    except Exception as e:
        return _do_return_error(e, "Error executing SQL.")


def retrieve_rows(query: str) -> Optional[Union[Any, Tuple]]:
    """
    Executes the given SQL query and returns the result in 4 modes:
      1.  N rows c column
      2.  N rows 1 column
      3.  1 row N columns
      4.  1 row 1 column

    Args:
      sql: The SQL query to execute.

    Returns:
      - A tuple of values if the query returns multiple rows with a single column each.
      - A tuple of values if the query returns a single row with multiple columns.
      - A single value if the query returns a single row with a single column.
      - None if an error occurs or the query returns no results.
    """
    from ..common.app_context_vars import sidekick

    try:
        err, _, data_cursor = db_fetch_rows(query)
        # TODO:
        if err:
            raise err

        rows = data_cursor.fetchall() if data_cursor else None

        if not rows:
            return tuple()
        elif len(rows) > 1 and len(rows[0]) > 1:
            # Multiple rows with multiple columns
            return tuple(tuple(row) for row in rows)
        elif len(rows) > 1:
            # Multiple rows with one column
            return tuple(line[0] for line in rows)
        elif len(rows[0]) > 1:
            # Single row with multiple columns
            return tuple(rows[0])
        else:
            # Single row with a single column
            return (rows[0][0],)
    except Exception as e:
        sidekick.app_log.error(f"An error occurred retrieving db data [{query}]: {e}")
        return tuple()


def retrieve_dict(query: str):
    """
    Executes the query and attempts to return the result as a dictionary,
    assuming the result consists of two columns (key, value) per row.

    Args:
      query: The SQL query to execute.

    Returns:
      - A dictionary where the first column is the key and the second column is the value.
      - An empty dictionary if the query returns no data or an error occurs.
    """
    from ..common.app_context_vars import sidekick

    data = retrieve_rows(query)

    result: ui_db_texts = {}
    try:
        if data and isinstance(data, tuple):
            # Check if data contains multiple rows of at least two columns
            if all(isinstance(row, tuple) and len(row) >= 2 for row in data):
                result = {row[0]: row[1] for row in data}
            # Handle single row with multiple columns (if returned by retrieve_rows)
            elif len(data) > 1 and not isinstance(data[0], tuple):
                # result = {data[0]: data[1]}
                result = {data[i]: data[i + 1] for i in range(0, len(data) - 1, 2)}
    except Exception as e:
        sidekick.app_log.error(
            f"An error occurred loading the dict from [{query}]: {e}"
        )
        result = {}

    # # Check if the result is a tuple of tuples (multiple rows)
    # if isinstance(data, tuple) and all(isinstance(row, tuple) and len(row) >= 2 for row in data):
    #     # We expect at least two columns (key, value) for dictionary creation
    #     return {row[0]: row[1] for row in data}

    return result  # ui_texts v2 .copy()  # there is a very strange error


def get_str_field_length(table_model: object, field_name: str) -> int:
    """
    Args:
      table_model: Flask SQLAlchemy Table Model
      field_name: the field name (must be string)
    Returns:
      the maximum size defined for the column in the Table Model (*not on the DB*)
    """
    fields = table_model.__table__.columns
    return fields[field_name].type.length


# TODO
def db_ups_error(e: Exception, msg_error: str, table_name: str) -> None:
    if not e is None:
        sidekick.display.error(
            f"Fatal error while fetching rows in table [{table_name}]: {msg_error}"
        )
        raise AppStumbled(msg_error, ModuleErrorCode.DB_FETCH_ROWS, False, True)

    return


def db_connstr_obfuscate(config: BaseConfig):
    """Hide any confidential info before it is displayed in debug mode"""
    import re

    db_uri_safe = re.sub(
        config.SQLALCHEMY_DATABASE_URI_REMOVE_PW_REGEX,
        config.SQLALCHEMY_DATABASE_URI_REPLACE_PW_STR,
        config.SQLALCHEMY_DATABASE_URI,
    )
    config.SQLALCHEMY_DATABASE_URI = db_uri_safe
    config.SQLALCHEMY_DATABASE_URI_REMOVE_PW_REGEX = ""
    config.SQLALCHEMY_DATABASE_URI_REPLACE_PW_STR = ""
    config.SQLALCHEMY_DATABASE_URI = ""

    return


# eof
